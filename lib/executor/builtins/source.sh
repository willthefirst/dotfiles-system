#!/usr/bin/env bash
# MODULE: executor/builtins/source
# PURPOSE: Source merge strategy - generates file that sources all layers
#
# PUBLIC API:
#   builtin_merge_source(config_ref, result_ref)
#       Generates a file that sources all layer config files.
#       Useful for shell configurations (bashrc, zshrc, etc.)
#
# DEPENDENCIES:
#   core/fs.sh, core/log.sh, core/backup.sh, core/errors.sh
#   contracts/tool_config.sh, contracts/hook_result.sh

[[ -n "${_BUILTIN_SOURCE_LOADED:-}" ]] && return 0
_BUILTIN_SOURCE_LOADED=1

# Source dependencies
_BUILTIN_SOURCE_DIR="${BASH_SOURCE[0]%/*}"
source "$_BUILTIN_SOURCE_DIR/../../core/fs.sh"
source "$_BUILTIN_SOURCE_DIR/../../core/log.sh"
source "$_BUILTIN_SOURCE_DIR/../../core/backup.sh"
source "$_BUILTIN_SOURCE_DIR/../../core/errors.sh"
source "$_BUILTIN_SOURCE_DIR/../../contracts/tool_config.sh"
source "$_BUILTIN_SOURCE_DIR/../../contracts/hook_result.sh"

# Find a pre-source config file within a layer directory
# Looks for {target_name}.pre or pre.{target_name} files
# Usage: _source_find_pre_config_file layer_path target_name
_source_find_pre_config_file() {
    local layer_path="$1"
    local target_name="$2"

    # Only look in directories
    if ! fs_is_dir "$layer_path"; then
        return 1
    fi

    # Candidate pre-source files in priority order
    local candidates=(
        "$layer_path/${target_name}.pre"
        "$layer_path/pre.${target_name}"
        "$layer_path/pre"
    )

    for candidate in "${candidates[@]}"; do
        if fs_is_file "$candidate"; then
            printf '%s' "$candidate"
            return 0
        fi
    done

    return 1
}

# Find a config file within a layer directory
# Usage: _source_find_config_file layer_path target_name
_source_find_config_file() {
    local layer_path="$1"
    local target_name="$2"

    # If layer_path is a file, return it
    if fs_is_file "$layer_path"; then
        printf '%s' "$layer_path"
        return 0
    fi

    # If layer_path is a directory, search for config file
    if ! fs_is_dir "$layer_path"; then
        return 1
    fi

    # Candidate files in priority order
    local candidates=(
        "$layer_path/$target_name"
        "$layer_path/config"
        "$layer_path/init"
    )

    for candidate in "${candidates[@]}"; do
        if fs_is_file "$candidate"; then
            printf '%s' "$candidate"
            return 0
        fi
    done

    # Fallback: first file in directory
    if [[ "$(fs_get_backend)" == "mock" ]]; then
        local files
        files=$(fs_list "$layer_path")
        if [[ -n "$files" ]]; then
            local first
            first=$(echo "$files" | head -1)
            if [[ -n "$first" ]] && fs_is_file "$layer_path/$first"; then
                printf '%s' "$layer_path/$first"
                return 0
            fi
        fi
    else
        local first_file
        first_file=$(find "$layer_path" -maxdepth 1 -type f 2>/dev/null | head -1)
        if [[ -n "$first_file" ]]; then
            printf '%s' "$first_file"
            return 0
        fi
    fi

    return 1
}

# Source merge strategy
# Usage: builtin_merge_source config result
builtin_merge_source() {
    local -n __bmso_config=$1
    local -n __bmso_result=$2

    local layer_count
    layer_count=$(tool_config_get_layer_count __bmso_config)

    if [[ $layer_count -eq 0 ]]; then
        hook_result_new_failure __bmso_result $E_INVALID_INPUT "No layers defined"
        return $E_INVALID_INPUT
    fi

    # Get target path
    local target
    target=$(tool_config_get_target __bmso_config)
    # Expand tilde
    if [[ "$target" == "~"* ]]; then
        target="${target/#\~/$HOME}"
    fi

    local target_parent
    target_parent=$(dirname "$target")
    local target_name
    target_name=$(basename "$target")

    # Ensure parent directory exists
    fs_mkdir "$target_parent"

    # Backup existing target
    if fs_exists "$target"; then
        local backup_path=""
        if ! backup_create "$target" backup_path; then
            hook_result_new_failure __bmso_result $E_BACKUP "Backup failed for: $target"
            return $E_BACKUP
        fi
        fs_remove "$target"
    fi

    # Start with header
    local content="# Auto-generated by dotfiles layering system
# This file sources configs from multiple layers
"
    local layers_found=0
    local pre_sources_found=0

    # First pass: collect and emit pre-source files (run before main configs)
    local i
    for ((i = 0; i < layer_count; i++)); do
        local layer_name
        layer_name=$(tool_config_get_layer_name __bmso_config "$i")
        local layer_path
        layer_path=$(tool_config_get_layer_resolved __bmso_config "$i")

        if [[ -z "$layer_path" ]]; then
            continue
        fi

        # Find pre-source file in layer
        local pre_config_file
        pre_config_file=$(_source_find_pre_config_file "$layer_path" "$target_name") || true

        if [[ -n "$pre_config_file" ]] && fs_is_file "$pre_config_file"; then
            if [[ $pre_sources_found -eq 0 ]]; then
                content+="
# Pre-init (sourced before main configs)
"
            fi
            content+="[ -f \"$pre_config_file\" ] && source \"$pre_config_file\"  # $layer_name
"
            log_detail "Added pre-source: $layer_name"
            ((pre_sources_found++)) || true
        fi
    done

    # Add source statements for all layers
    for ((i = 0; i < layer_count; i++)); do
        local layer_name
        layer_name=$(tool_config_get_layer_name __bmso_config "$i")
        local layer_path
        layer_path=$(tool_config_get_layer_resolved __bmso_config "$i")

        if [[ -z "$layer_path" ]]; then
            log_warn "Layer $layer_name: not resolved"
            continue
        fi

        # Find config file in layer
        local config_file
        config_file=$(_source_find_config_file "$layer_path" "$target_name") || true

        if [[ -n "$config_file" ]] && fs_is_file "$config_file"; then
            content+="
# Layer: $layer_name
[ -f \"$config_file\" ] && source \"$config_file\"
"
            log_detail "Added source: $layer_name"
            ((layers_found++)) || true
        else
            log_warn "No config file in layer: $layer_path"
        fi
    done

    if [[ $layers_found -eq 0 ]]; then
        hook_result_new_failure __bmso_result $E_NOT_FOUND "No config files found in any layer"
        return $E_NOT_FOUND
    fi

    # Write source file
    fs_write "$target" "$content"

    log_ok "Source config written: $target"

    hook_result_new __bmso_result 1
    hook_result_add_file __bmso_result "$target"
    return $E_OK
}
